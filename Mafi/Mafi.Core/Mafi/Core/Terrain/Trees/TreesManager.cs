// Decompiled with JetBrains decompiler
// Type: Mafi.Core.Terrain.Trees.TreesManager
// Assembly: Mafi.Core, Version=0.6.3.0, Culture=neutral, PublicKeyToken=null
// MVID: 2D94E377-7747-46A4-A766-4DF7ABFEBD30
// Assembly location: D:\GameLibrary\SteamLibrary\steamapps\common\Captain of Industry\Captain of Industry_Data\Managed\Mafi.Core.dll
// XML documentation location: D:\GameLibrary\SteamLibrary\steamapps\common\Captain of Industry\Captain of Industry_Data\Managed\Mafi.Core.xml

using eLxG93FZl5M3yHxFGb;
using Mafi.Collections;
using Mafi.Core.Buildings.Forestry;
using Mafi.Core.Entities;
using Mafi.Core.Entities.Dynamic;
using Mafi.Core.Input;
using Mafi.Core.PathFinding;
using Mafi.Core.Products;
using Mafi.Core.Simulation;
using Mafi.Core.Terrain.Designation;
using Mafi.Core.Terrain.Generation;
using Mafi.Core.Terrain.Props;
using Mafi.Core.Vehicles.TreeHarvesters;
using Mafi.Serialization;
using System;
using System.Collections.Generic;
using System.Linq;

#nullable disable
namespace Mafi.Core.Terrain.Trees
{
  [GlobalDependency(RegistrationMode.AsEverything, false, false)]
  [GenerateSerializer(false, null, 0)]
  public class TreesManager : 
    ITreesManager,
    ITreeHarvestingManager,
    ITreePlantingManager,
    ICommandProcessor<DesignateHarvestedTreesCmd>,
    IAction<DesignateHarvestedTreesCmd>
  {
    private static readonly Action<object, BlobWriter> s_serializeDataDelayedAction;
    private static readonly Action<object, BlobReader> s_deserializeDataDelayedAction;
    /// <summary>
    /// Trees generated by the generator should have this value set as <see cref="F:Mafi.Core.Terrain.Trees.TreeData.PlantedAtTick" />.
    /// </summary>
    public static readonly int GENERATED_TREE_PLANTED_AT_TICK;
    /// <summary>
    /// Stumps sink over time. They are not destroyed in this time, that's defined
    /// by the upper and lower bounds.
    /// </summary>
    public static readonly Fix32 STUMP_SINK_RATE_PER_MONTH;
    /// <summary>
    /// If terrain goes up by this amount, we collapse the stump.
    /// </summary>
    private static readonly ThicknessTilesF STUMP_COLLAPSE_UPPER_BOUND;
    /// <summary>
    /// If terrain goes down by this amount, we collapse the stump.
    /// </summary>
    private static readonly ThicknessTilesF STUMP_COLLAPSE_LOWER_BOUND;
    /// <summary>
    /// If terrain goes up by this amount, we collapse the tree.
    /// </summary>
    private static readonly ThicknessTilesF TREE_COLLAPSE_UPPER_BOUND;
    /// <summary>
    /// If terrain goes down by this amount, we collapse the tree.
    /// </summary>
    private static readonly ThicknessTilesF TREE_COLLAPSE_LOWER_BOUND;
    /// <summary>
    /// Maximum number of chunks to search for a tree to harvest.
    /// </summary>
    private static readonly int MAX_CHUNKS_TO_SEARCH;
    /// <summary>
    /// Trees can be planted on a tile if farmable thickness reaches this value before
    /// non farmable thickness does, scanning downward.
    /// </summary>
    private static readonly ThicknessTilesF TREE_FERTILITY_REQUIREMENT;
    /// <summary>
    /// When removing trees we split chunks into subchunks to minimize load per tick.
    /// More subchunks will likely result in more overall load, but also more balanced load.
    /// Must evenly divide into TerrainTile.TILES_PER_CHUNK.
    /// </summary>
    private static readonly int FOREST_FLOOR_REMOVE_SUBCHUNKS;
    private static readonly int TILES_PER_UPDATE;
    private static readonly ThicknessTilesF MAX_FLOOR_THICKNESS_GAIN_PER_MONTH;
    private static readonly ThicknessTilesF MAX_FLOOR_THICKNESS_LOSS_PER_MONTH;
    public static readonly ThicknessTilesF MAX_FLOOR_THICKNESS_TOTAL;
    private readonly Event<TreeData> m_treeAdded;
    private readonly Event<TreeData> m_treeRemoved;
    private readonly Event<TreeStumpData> m_stumpAdded;
    private readonly Event<TreeStumpData> m_stumpRemoved;
    private readonly Event<TreeData> m_treePreviewAdded;
    private readonly Event<TreeData> m_treePreviewRemoved;
    private readonly Event<TreeId> m_treeAddedToHarvest;
    private readonly Event<TreeId> m_treeRemovedFromHarvest;
    [NewInSaveVersion(140, null, "new()", null, null)]
    private readonly Event<TreeId> m_manualTreePlaced;
    private readonly TerrainManager m_terrainManager;
    [NewInSaveVersion(117, null, null, typeof (TerrainOccupancyManager), null)]
    private readonly TerrainOccupancyManager m_occupancyManager;
    [NewInSaveVersion(120, null, null, typeof (FarmableManager), null)]
    private readonly FarmableManager m_farmableManager;
    [DoNotSave(140, null)]
    [OnlyForSaveCompatibility(null)]
    private readonly ITerrainPropsManager m_terrainPropManager;
    [NewInSaveVersion(140, null, null, typeof (LazyResolve<ITerrainPropsManager>), null)]
    private readonly LazyResolve<ITerrainPropsManager> m_terrainPropManagerLazy;
    private readonly IProductsManager m_productsManager;
    private readonly IForestryTowersManager m_forestryTowersManager;
    private readonly LazyResolve<IVehiclePathFindingManager> m_vehiclePathFindingManager;
    private readonly ICalendar m_calendar;
    private IRandom m_randomNumberGenerator;
    private readonly TileFlagReporter m_tileFlagReporter;
    private TileFlagReporter m_tileStumpFlagReporter;
    [DoNotSaveCreateNewOnLoad(null, 0)]
    private readonly Dict<TreeId, TreeData> m_trees;
    private readonly Dict<TreeId, TreeStumpData> m_stumps;
    private readonly Dict<TreeId, TreeData> m_manualTrees;
    private readonly Set<TreeId> m_reservedManualTrees;
    [DoNotSaveCreateNewOnLoad(null, 0)]
    private readonly Dict<ProductProto.ID, TreesManager.TreesGroup> m_treeGroups;
    private readonly Dict<Chunk2i, TreesManager.StumpsChunk> m_stumpChunks;
    private readonly Dict<Chunk2i, TreesManager.TreeDistanceChunk> m_treeDistanceChunks;
    private readonly Lyst<Chunk2i> m_forestFloorUpdateAddQueue;
    private readonly Lyst<Chunk2i> m_forestFloorUpdateRemoveQueue;
    private int m_forestFloorAddChunksPerStep;
    private int m_forestFloorRemoveSubChunksPerStep;
    private int m_forestFloorUpdateStep;
    private int m_forestFloorUpdateMonth;
    /// <summary>Trees that were partially harvested.</summary>
    [Obsolete]
    private readonly Dict<TreeId, Quantity> m_partiallyHarvested;
    /// <summary>
    /// A set of trees that were created by terrain generator but removed later during game.
    /// </summary>
    private readonly Set<TreeId> m_removedTreesCreatedWithTerrainGenerator;
    [DoNotSave(0, null)]
    private Lyst<TreeData> m_saveDataTmp;
    [DoNotSave(0, null)]
    private Lyst<TreeId> m_loadedSelectedTrees;
    private readonly Set<ForestryTower> m_forestryTowers;
    [DoNotSave(0, null)]
    private Lyst<TreeId> m_loadedReservedTrees;
    [DoNotSaveCreateNewOnLoad("new Lyst<TreeId>(canOmitClearing: true)", 0)]
    private readonly Lyst<TreeId> m_treesInAreaTmp;
    [DoNotSaveCreateNewOnLoad("new()", 0)]
    private readonly Lyst<TreeId> m_stumpsToRemove;
    [DoNotSave(0, null)]
    private bool m_logForestFlowGrowthTiming;

    public static void Serialize(TreesManager value, BlobWriter writer)
    {
      if (!writer.TryStartClassSerialization<TreesManager>(value))
        return;
      writer.EnqueueDataSerialization((object) value, TreesManager.s_serializeDataDelayedAction);
    }

    protected virtual void SerializeData(BlobWriter writer)
    {
      writer.WriteGeneric<ICalendar>(this.m_calendar);
      writer.WriteInt(this.m_forestFloorAddChunksPerStep);
      writer.WriteInt(this.m_forestFloorRemoveSubChunksPerStep);
      Lyst<Chunk2i>.Serialize(this.m_forestFloorUpdateAddQueue, writer);
      writer.WriteInt(this.m_forestFloorUpdateMonth);
      Lyst<Chunk2i>.Serialize(this.m_forestFloorUpdateRemoveQueue, writer);
      writer.WriteInt(this.m_forestFloorUpdateStep);
      Set<ForestryTower>.Serialize(this.m_forestryTowers, writer);
      writer.WriteGeneric<IForestryTowersManager>(this.m_forestryTowersManager);
      Event<TreeId>.Serialize(this.m_manualTreePlaced, writer);
      Dict<TreeId, TreeData>.Serialize(this.m_manualTrees, writer);
      TerrainOccupancyManager.Serialize(this.m_occupancyManager, writer);
      Dict<TreeId, Quantity>.Serialize(this.m_partiallyHarvested, writer);
      writer.WriteGeneric<IProductsManager>(this.m_productsManager);
      writer.WriteGeneric<IRandom>(this.m_randomNumberGenerator);
      Set<TreeId>.Serialize(this.m_removedTreesCreatedWithTerrainGenerator, writer);
      Set<TreeId>.Serialize(this.m_reservedManualTrees, writer);
      Event<TreeStumpData>.Serialize(this.m_stumpAdded, writer);
      Dict<Chunk2i, TreesManager.StumpsChunk>.Serialize(this.m_stumpChunks, writer);
      Event<TreeStumpData>.Serialize(this.m_stumpRemoved, writer);
      Dict<TreeId, TreeStumpData>.Serialize(this.m_stumps, writer);
      TerrainManager.Serialize(this.m_terrainManager, writer);
      LazyResolve<ITerrainPropsManager>.Serialize(this.m_terrainPropManagerLazy, writer);
      TileFlagReporter.Serialize(this.m_tileFlagReporter, writer);
      TileFlagReporter.Serialize(this.m_tileStumpFlagReporter, writer);
      Event<TreeData>.Serialize(this.m_treeAdded, writer);
      Event<TreeId>.Serialize(this.m_treeAddedToHarvest, writer);
      Dict<Chunk2i, TreesManager.TreeDistanceChunk>.Serialize(this.m_treeDistanceChunks, writer);
      Event<TreeData>.Serialize(this.m_treePreviewAdded, writer);
      Event<TreeData>.Serialize(this.m_treePreviewRemoved, writer);
      Event<TreeData>.Serialize(this.m_treeRemoved, writer);
      Event<TreeId>.Serialize(this.m_treeRemovedFromHarvest, writer);
      LazyResolve<IVehiclePathFindingManager>.Serialize(this.m_vehiclePathFindingManager, writer);
      writer.WriteInt(this.ReservedCount);
      Lyst<TreeData>.Serialize(this.SaveDataNonGeneratedTrees, writer);
      Lyst<TreeId>.Serialize(this.SaveDataReservedTrees, writer);
      Lyst<TreeId>.Serialize(this.SaveDataSelectedTrees, writer);
      writer.WriteInt(this.SelectedToHarvestCount);
    }

    public static TreesManager Deserialize(BlobReader reader)
    {
      TreesManager treesManager;
      if (reader.TryStartClassDeserialization<TreesManager>(out treesManager))
        reader.EnqueueDataDeserialization((object) treesManager, TreesManager.s_deserializeDataDelayedAction);
      return treesManager;
    }

    protected virtual void DeserializeData(BlobReader reader)
    {
      reader.SetField<TreesManager>(this, "m_calendar", (object) reader.ReadGenericAs<ICalendar>());
      reader.RegisterResolvedMember<TreesManager>(this, "m_farmableManager", typeof (FarmableManager), true);
      this.m_forestFloorAddChunksPerStep = reader.ReadInt();
      this.m_forestFloorRemoveSubChunksPerStep = reader.ReadInt();
      reader.SetField<TreesManager>(this, "m_forestFloorUpdateAddQueue", (object) Lyst<Chunk2i>.Deserialize(reader));
      this.m_forestFloorUpdateMonth = reader.ReadInt();
      reader.SetField<TreesManager>(this, "m_forestFloorUpdateRemoveQueue", (object) Lyst<Chunk2i>.Deserialize(reader));
      this.m_forestFloorUpdateStep = reader.ReadInt();
      reader.SetField<TreesManager>(this, "m_forestryTowers", (object) Set<ForestryTower>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_forestryTowersManager", (object) reader.ReadGenericAs<IForestryTowersManager>());
      reader.SetField<TreesManager>(this, "m_manualTreePlaced", reader.LoadedSaveVersion >= 140 ? (object) Event<TreeId>.Deserialize(reader) : (object) new Event<TreeId>());
      reader.SetField<TreesManager>(this, "m_manualTrees", (object) Dict<TreeId, TreeData>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_occupancyManager", reader.LoadedSaveVersion >= 117 ? (object) TerrainOccupancyManager.Deserialize(reader) : (object) (TerrainOccupancyManager) null);
      if (reader.LoadedSaveVersion < 117)
        reader.RegisterResolvedMember<TreesManager>(this, "m_occupancyManager", typeof (TerrainOccupancyManager), true);
      reader.SetField<TreesManager>(this, "m_partiallyHarvested", (object) Dict<TreeId, Quantity>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_productsManager", (object) reader.ReadGenericAs<IProductsManager>());
      this.m_randomNumberGenerator = reader.ReadGenericAs<IRandom>();
      reader.SetField<TreesManager>(this, "m_removedTreesCreatedWithTerrainGenerator", (object) Set<TreeId>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_reservedManualTrees", (object) Set<TreeId>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_stumpAdded", (object) Event<TreeStumpData>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_stumpChunks", (object) Dict<Chunk2i, TreesManager.StumpsChunk>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_stumpRemoved", (object) Event<TreeStumpData>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_stumps", (object) Dict<TreeId, TreeStumpData>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_stumpsToRemove", (object) new Lyst<TreeId>());
      reader.SetField<TreesManager>(this, "m_terrainManager", (object) TerrainManager.Deserialize(reader));
      if (reader.LoadedSaveVersion < 140)
        reader.SetField<TreesManager>(this, "m_terrainPropManager", (object) reader.ReadGenericAs<ITerrainPropsManager>());
      reader.SetField<TreesManager>(this, "m_terrainPropManagerLazy", reader.LoadedSaveVersion >= 140 ? (object) LazyResolve<ITerrainPropsManager>.Deserialize(reader) : (object) (LazyResolve<ITerrainPropsManager>) null);
      if (reader.LoadedSaveVersion < 140)
        reader.RegisterResolvedMember<TreesManager>(this, "m_terrainPropManagerLazy", typeof (LazyResolve<ITerrainPropsManager>), true);
      reader.SetField<TreesManager>(this, "m_tileFlagReporter", (object) TileFlagReporter.Deserialize(reader));
      this.m_tileStumpFlagReporter = TileFlagReporter.Deserialize(reader);
      reader.SetField<TreesManager>(this, "m_treeAdded", (object) Event<TreeData>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_treeAddedToHarvest", (object) Event<TreeId>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_treeDistanceChunks", (object) Dict<Chunk2i, TreesManager.TreeDistanceChunk>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_treeGroups", (object) new Dict<ProductProto.ID, TreesManager.TreesGroup>());
      reader.SetField<TreesManager>(this, "m_treePreviewAdded", (object) Event<TreeData>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_treePreviewRemoved", (object) Event<TreeData>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_treeRemoved", (object) Event<TreeData>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_treeRemovedFromHarvest", (object) Event<TreeId>.Deserialize(reader));
      reader.SetField<TreesManager>(this, "m_trees", (object) new Dict<TreeId, TreeData>());
      reader.SetField<TreesManager>(this, "m_treesInAreaTmp", (object) new Lyst<TreeId>(true));
      reader.SetField<TreesManager>(this, "m_vehiclePathFindingManager", (object) LazyResolve<IVehiclePathFindingManager>.Deserialize(reader));
      this.ReservedCount = reader.ReadInt();
      this.SaveDataNonGeneratedTrees = Lyst<TreeData>.Deserialize(reader);
      this.SaveDataReservedTrees = Lyst<TreeId>.Deserialize(reader);
      this.SaveDataSelectedTrees = Lyst<TreeId>.Deserialize(reader);
      this.SelectedToHarvestCount = reader.ReadInt();
      reader.RegisterInitAfterLoad<TreesManager>(this, "initSelf", InitPriority.Low);
    }

    [OnlyForSaveCompatibility(null)]
    public IEvent<TreeData> TreeAdded => (IEvent<TreeData>) this.m_treeAdded;

    public IEvent<TreeData> TreeRemoved => (IEvent<TreeData>) this.m_treeRemoved;

    public IEvent<TreeStumpData> StumpAdded => (IEvent<TreeStumpData>) this.m_stumpAdded;

    public IEvent<TreeStumpData> StumpRemoved => (IEvent<TreeStumpData>) this.m_stumpRemoved;

    public IEvent<TreeData> TreePreviewAdded => (IEvent<TreeData>) this.m_treePreviewAdded;

    public IEvent<TreeData> TreePreviewRemoved => (IEvent<TreeData>) this.m_treePreviewRemoved;

    public IEvent<TreeId> TreeAddedToHarvest => (IEvent<TreeId>) this.m_treeAddedToHarvest;

    public IEvent<TreeId> TreeRemovedFromHarvest => (IEvent<TreeId>) this.m_treeRemovedFromHarvest;

    public IEvent<TreeId> ManualTreePlaced => (IEvent<TreeId>) this.m_manualTreePlaced;

    public event Action<TreeId> TreeCollapseTriggered;

    public IReadOnlyDictionary<TreeId, TreeData> Trees
    {
      get => (IReadOnlyDictionary<TreeId, TreeData>) this.m_trees;
    }

    public int TreesCount => this.m_trees.Count;

    public IReadOnlyDictionary<TreeId, TreeStumpData> Stumps
    {
      get => (IReadOnlyDictionary<TreeId, TreeStumpData>) this.m_stumps;
    }

    public IReadOnlyDictionary<TreeId, TreeData> PreviewTrees
    {
      get => (IReadOnlyDictionary<TreeId, TreeData>) this.m_manualTrees;
    }

    private Lyst<TreeData> SaveDataNonGeneratedTrees
    {
      get => this.getSaveData();
      set => this.m_saveDataTmp = value;
    }

    private Lyst<TreeId> SaveDataSelectedTrees
    {
      get => this.EnumerateSelectedTrees().ToLyst<TreeId>();
      set => this.m_loadedSelectedTrees = value;
    }

    private Lyst<TreeId> SaveDataReservedTrees
    {
      get => this.EnumerateReservedTrees().ToLyst<TreeId>();
      set => this.m_loadedReservedTrees = value;
    }

    public int SelectedToHarvestCount { get; private set; }

    public int ReservedCount { get; private set; }

    public TreeData this[TreeId id] => this.m_trees.GetValueOrDefault<TreeId, TreeData>(id);

    public TreesManager(
      TerrainManager terrainManager,
      TerrainOccupancyManager occupancyManager,
      FarmableManager farmableManager,
      LazyResolve<ITerrainPropsManager> terrainPropManager,
      IProductsManager productsManager,
      IForestryTowersManager forestryTowersManager,
      LazyResolve<IVehiclePathFindingManager> vehiclePathFindingManager,
      ICalendar calendar,
      ISimLoopEvents simLoopEvents,
      RandomProvider randomProvider)
    {
      MBiHIp97M4MqqbtZOh.rMWAw2OR8();
      this.m_treeAdded = new Event<TreeData>();
      this.m_treeRemoved = new Event<TreeData>();
      this.m_stumpAdded = new Event<TreeStumpData>();
      this.m_stumpRemoved = new Event<TreeStumpData>();
      this.m_treePreviewAdded = new Event<TreeData>();
      this.m_treePreviewRemoved = new Event<TreeData>();
      this.m_treeAddedToHarvest = new Event<TreeId>();
      this.m_treeRemovedFromHarvest = new Event<TreeId>();
      this.m_manualTreePlaced = new Event<TreeId>();
      this.m_trees = new Dict<TreeId, TreeData>();
      this.m_stumps = new Dict<TreeId, TreeStumpData>();
      this.m_manualTrees = new Dict<TreeId, TreeData>();
      this.m_reservedManualTrees = new Set<TreeId>();
      this.m_treeGroups = new Dict<ProductProto.ID, TreesManager.TreesGroup>();
      this.m_stumpChunks = new Dict<Chunk2i, TreesManager.StumpsChunk>();
      this.m_treeDistanceChunks = new Dict<Chunk2i, TreesManager.TreeDistanceChunk>();
      this.m_forestFloorUpdateAddQueue = new Lyst<Chunk2i>();
      this.m_forestFloorUpdateRemoveQueue = new Lyst<Chunk2i>();
      this.m_partiallyHarvested = new Dict<TreeId, Quantity>();
      this.m_removedTreesCreatedWithTerrainGenerator = new Set<TreeId>();
      this.m_saveDataTmp = new Lyst<TreeData>();
      this.m_loadedSelectedTrees = new Lyst<TreeId>();
      this.m_forestryTowers = new Set<ForestryTower>();
      this.m_loadedReservedTrees = new Lyst<TreeId>();
      this.m_treesInAreaTmp = new Lyst<TreeId>(true);
      this.m_stumpsToRemove = new Lyst<TreeId>();
      // ISSUE: explicit constructor call
      base.\u002Ector();
      this.m_terrainManager = terrainManager;
      this.m_occupancyManager = occupancyManager;
      this.m_farmableManager = farmableManager;
      this.m_terrainPropManagerLazy = terrainPropManager;
      this.m_productsManager = productsManager;
      this.m_forestryTowersManager = forestryTowersManager;
      this.m_vehiclePathFindingManager = vehiclePathFindingManager;
      this.m_calendar = calendar;
      this.m_randomNumberGenerator = randomProvider.GetSimRandomFor((object) this);
      this.m_tileFlagReporter = terrainManager.CreateNewTileFlagReporter(nameof (Trees), true, true, false);
      this.m_tileStumpFlagReporter = terrainManager.CreateNewTileFlagReporter(nameof (Stumps), false, true, false);
      this.m_forestryTowersManager.OnTowerAdded.Add<TreesManager>(this, new Action<ForestryTower, EntityAddReason>(this.AddControlTower));
      this.m_forestryTowersManager.OnTowerRemoved.Add<TreesManager>(this, new Action<ForestryTower, EntityRemoveReason>(this.RemoveControlTower));
      terrainManager.HeightChanged.Add<TreesManager>(this, new Action<Tile2iAndIndex>(this.terrainHeightChanged));
      terrainManager.TerrainDataGenerated.Add<TreesManager>(this, new Action<GeneratedTerrainData, bool>(this.terrainDataGenerated));
      terrainManager.TerrainGeneratedButNotLoaded.Add<TreesManager>(this, new Action(this.terrainGeneratedButNotLoaded));
      calendar.NewMonth.Add<TreesManager>(this, new Action(this.onNewMonth));
      simLoopEvents.Update.Add<TreesManager>(this, new Action(this.simUpdate));
    }

    [OnlyForSaveCompatibility(null)]
    [InitAfterLoad(InitPriority.Low)]
    private void initSelf(int saveVersion, DependencyResolver dependencyResolver)
    {
      if (saveVersion >= 123)
        return;
      this.m_forestryTowersManager.OnTowerAdded.Add<TreesManager>(this, new Action<ForestryTower, EntityAddReason>(this.AddControlTower));
      this.m_forestryTowersManager.OnTowerRemoved.Add<TreesManager>(this, new Action<ForestryTower, EntityRemoveReason>(this.RemoveControlTower));
      this.m_forestryTowers.Clear();
      EntitiesManager dep;
      if (dependencyResolver.TryGetResolvedDependency<EntitiesManager>(out dep))
        this.m_forestryTowers.AddRange(dep.GetAllEntitiesOfType<ForestryTower>());
      else
        Log.Error("Failed to resolve entities manager.");
    }

    private void onNewMonth()
    {
      this.m_stumpsToRemove.Clear();
      foreach (TreeId key in this.m_stumps.Keys)
      {
        ref TreeStumpData local = ref this.m_stumps.GetRefValue(key, out bool _);
        if (this.m_terrainManager.GetHeight(local.Position) + local.GetDeltaHeight(this.m_calendar) < local.PlantedAtHeight - TreesManager.STUMP_COLLAPSE_LOWER_BOUND)
          this.m_stumpsToRemove.Add(key);
      }
      foreach (TreeId id in this.m_stumpsToRemove)
        this.TryRemoveStump(id);
      this.m_forestFloorUpdateAddQueue.Clear();
      this.m_forestFloorUpdateRemoveQueue.Clear();
      foreach (Chunk2i key in this.m_treeDistanceChunks.Keys)
      {
        this.m_forestFloorUpdateAddQueue.Add(key);
        if (this.m_treeDistanceChunks[key].IsForestFloorDirty)
        {
          this.m_forestFloorUpdateRemoveQueue.Add(key);
          this.m_treeDistanceChunks[key].IsForestFloorDirty = false;
        }
      }
      this.m_forestFloorUpdateStep = 0;
      ++this.m_forestFloorUpdateMonth;
      this.m_forestFloorAddChunksPerStep = this.m_forestFloorUpdateAddQueue.Count.CeilDivPositive(600);
      this.m_forestFloorRemoveSubChunksPerStep = (this.m_forestFloorUpdateRemoveQueue.Count * TreesManager.FOREST_FLOOR_REMOVE_SUBCHUNKS).CeilDivPositive(600);
      if (this.m_forestFloorRemoveSubChunksPerStep < 8)
        return;
      Log.Warning(string.Format("Forest floor remove subchunks/tick getting larger than expected {0}", (object) this.m_forestFloorRemoveSubChunksPerStep));
    }

    private void simUpdate()
    {
      for (int index1 = 0; index1 < this.m_forestFloorAddChunksPerStep; ++index1)
      {
        int index2 = this.m_forestFloorUpdateStep * this.m_forestFloorAddChunksPerStep + index1;
        if (index2 < this.m_forestFloorUpdateAddQueue.Count)
        {
          Chunk2i forestFloorUpdateAdd = this.m_forestFloorUpdateAddQueue[index2];
          foreach (TreesManager.TreesGroup treesGroup in this.m_treeGroups.Values)
          {
            foreach (TreeId key in treesGroup.GetAllTreesOnChunk(forestFloorUpdateAdd))
            {
              TreeData tree = this.m_trees[key];
              if (!tree.CreatedByTerrainGenerator && !tree.Proto.ForestFloorMaterial.IsNone)
              {
                Percent scale = tree.GetScale(this.m_calendar);
                if (!(scale >= Percent.Hundred) && ((int) tree.Id.Position.X + (int) tree.Id.Position.Y).Abs() % 8 == this.m_forestFloorUpdateMonth % 8)
                {
                  int num1 = scale.ApplyCeiled(tree.Proto.SpacingToOtherTree * 2);
                  int num2 = num1 * num1;
                  Fix32 fix32 = 1.ToFix32() / (tree.Proto.SpacingToOtherTree * 2 + 1);
                  TerrainMaterialSlimId slimId = tree.Proto.ForestFloorMaterial.Value.SlimId;
                  TerrainTile plusYneighbor = this.m_terrainManager[tree.Position.Tile2iRounded + new RelTile2i(-num1, -num1)];
                  int num3 = -num1;
                  while (num3 <= num1)
                  {
                    TerrainTile terrainTile = plusYneighbor;
                    int num4 = num3 * num3;
                    int num5 = -num1;
                    while (num5 <= num1)
                    {
                      int smallInt = num5 * num5 + num4;
                      if (smallInt > num2)
                      {
                        if (num5 > 0)
                          break;
                      }
                      else
                      {
                        ThicknessTilesF rhs = 8 * scale.Apply(Fix32.One - smallInt.FastSqrtSmallInt() * fix32) * TreesManager.MAX_FLOOR_THICKNESS_GAIN_PER_MONTH;
                        if (!rhs.IsNotPositive && terrainTile.FirstLayer.Material.CanBeConvertedToForestFloor)
                        {
                          TerrainMaterialThickness firstLayer = terrainTile.FirstLayer;
                          ThicknessTilesF thickness = firstLayer.Thickness;
                          ThicknessTilesF thicknessTilesF;
                          TerrainMaterialThicknessSlim materialThicknessSlim;
                          if (firstLayer.Material.IsForestFloor)
                          {
                            if (!(thickness >= TreesManager.MAX_FLOOR_THICKNESS_TOTAL) && terrainTile.SecondLayer.Material.CanBeConvertedToForestFloor)
                            {
                              thicknessTilesF = terrainTile.SecondLayer.Thickness.Min(rhs).Min(TreesManager.MAX_FLOOR_THICKNESS_TOTAL - thickness);
                              Assert.That<Fix32>(thicknessTilesF.Value).IsNotNegative();
                              if (!thicknessTilesF.Value.IsNotPositive)
                                materialThicknessSlim = terrainTile.TerrainManager.MineMaterialFromSecondLayer_RawNoEvents(terrainTile.DataIndex, thicknessTilesF);
                              else
                                goto label_19;
                            }
                            else
                              goto label_19;
                          }
                          else
                          {
                            thicknessTilesF = thickness.Min(rhs);
                            materialThicknessSlim = this.m_terrainManager.MineMaterial_RawNoEvents(terrainTile.DataIndex, thicknessTilesF);
                          }
                          Assert.That<Fix32>(materialThicknessSlim.Thickness.Value).IsEqualTo(thicknessTilesF.Value);
                          terrainTile.TerrainManager.DumpMaterial_NoHeightChange(terrainTile.CoordAndIndex, thicknessTilesF.Of(slimId));
                        }
                      }
label_19:
                      ++num5;
                      terrainTile = terrainTile.PlusXNeighbor;
                    }
                    ++num3;
                    plusYneighbor = plusYneighbor.PlusYNeighbor;
                  }
                }
              }
            }
          }
        }
        else
          break;
      }
      for (int index = 0; index < this.m_forestFloorRemoveSubChunksPerStep; ++index)
      {
        int num6 = this.m_forestFloorUpdateStep * this.m_forestFloorRemoveSubChunksPerStep + index;
        if (num6 < this.m_forestFloorUpdateRemoveQueue.Count * TreesManager.FOREST_FLOOR_REMOVE_SUBCHUNKS)
        {
          Chunk2i floorUpdateRemove = this.m_forestFloorUpdateRemoveQueue[num6 / TreesManager.FOREST_FLOOR_REMOVE_SUBCHUNKS];
          int num7 = num6 % TreesManager.FOREST_FLOOR_REMOVE_SUBCHUNKS;
          TreesManager.TreeDistanceChunk treeDistanceChunk;
          if (this.m_treeDistanceChunks.TryGetValue(floorUpdateRemove, out treeDistanceChunk))
          {
            if (this.m_randomNumberGenerator.NextInt() % 4 != 0)
            {
              treeDistanceChunk.IsForestFloorDirty = true;
            }
            else
            {
              bool flag = false;
              int num8 = num7 * TreesManager.TILES_PER_UPDATE;
              int num9 = num8 + TreesManager.TILES_PER_UPDATE;
              for (int rawIndex = num8; rawIndex < num9; ++rawIndex)
              {
                if (treeDistanceChunk.GetRawDistanceAt(rawIndex) == (byte) 0)
                {
                  TerrainTile terrainTile = this.m_terrainManager[floorUpdateRemove + new TileInChunk2i(rawIndex % 64, rawIndex / 64)];
                  TerrainMaterialThicknessSlim slimOrNoneNoBedrock = this.m_terrainManager.GetFirstLayerSlimOrNoneNoBedrock(terrainTile.DataIndex);
                  if (!slimOrNoneNoBedrock.IsNone)
                  {
                    TerrainMaterialProto full = slimOrNoneNoBedrock.SlimId.ToFull(this.m_terrainManager);
                    TerrainMaterialThicknessSlim materialThicknessSlim1 = new TerrainMaterialThicknessSlim();
                    if (!full.IsForestFloor)
                    {
                      materialThicknessSlim1 = this.m_terrainManager.GetSecondLayerSlimOrNoneNoBedrock(terrainTile.DataIndex);
                      if (!materialThicknessSlim1.SlimId.ToFull(this.m_terrainManager).IsForestFloor)
                        continue;
                    }
                    ThicknessTilesF thickness = materialThicknessSlim1.Thickness;
                    ThicknessTilesF thicknessTilesF;
                    TerrainMaterialThicknessSlim materialThicknessSlim2;
                    if (thickness.IsPositive)
                    {
                      if (!(terrainTile.FirstLayer.Thickness >= ThicknessTilesF.One))
                      {
                        thickness = materialThicknessSlim1.Thickness;
                        thicknessTilesF = thickness.Min(TreesManager.MAX_FLOOR_THICKNESS_LOSS_PER_MONTH * 4);
                        materialThicknessSlim2 = terrainTile.TerrainManager.MineMaterialFromSecondLayer_RawNoEvents(terrainTile.DataIndex, thicknessTilesF);
                      }
                      else
                        continue;
                    }
                    else
                    {
                      thickness = slimOrNoneNoBedrock.Thickness;
                      thicknessTilesF = thickness.Min(TreesManager.MAX_FLOOR_THICKNESS_LOSS_PER_MONTH * 4);
                      materialThicknessSlim2 = terrainTile.TerrainManager.MineMaterial_RawNoEvents(terrainTile.DataIndex, thicknessTilesF);
                    }
                    flag = true;
                    Assert.That<Fix32>(materialThicknessSlim2.Thickness.Value).IsEqualTo(thicknessTilesF.Value);
                    Option<TerrainMaterialProto> recoveredMaterialProto = full.MinedProduct.TerrainMaterial.Value.RecoveredMaterialProto;
                    TerrainMaterialThicknessSlim materialThicknessSlim3 = !recoveredMaterialProto.HasValue || !recoveredMaterialProto.Value.IsNotPhantom ? new TerrainMaterialThicknessSlim(full.MinedProduct.TerrainMaterial.Value.SlimId, thicknessTilesF) : new TerrainMaterialThicknessSlim(recoveredMaterialProto.Value.SlimId, thicknessTilesF);
                    if (!terrainTile.SecondLayer.Material.IsFarmable)
                      terrainTile.TerrainManager.DumpMaterialToSecondLayer_NoHeightChange(terrainTile.CoordAndIndex, materialThicknessSlim3);
                    else if (!terrainTile.TerrainManager.TryAddMaterialToUndergroundTopFourLayer_NoHeightChange(terrainTile.CoordAndIndex, materialThicknessSlim3))
                      terrainTile.TerrainManager.DumpMaterialToSecondLayer_NoHeightChange(terrainTile.CoordAndIndex, materialThicknessSlim3);
                  }
                }
              }
              if (flag)
                treeDistanceChunk.IsForestFloorDirty = true;
            }
          }
        }
        else
          break;
      }
      ++this.m_forestFloorUpdateStep;
    }

    public bool TryGetTree(TreeId tree, out TreeData treeData)
    {
      return this.m_trees.TryGetValue(tree, out treeData);
    }

    public IEnumerable<TreeId> EnumerateSelectedTrees()
    {
      return this.m_treeGroups.Values.Where<TreesManager.TreesGroup>((Func<TreesManager.TreesGroup, bool>) (g => g.SelectedCount > 0)).SelectMany<TreesManager.TreesGroup, TreesManager.ITreesChunk>((Func<TreesManager.TreesGroup, IEnumerable<TreesManager.ITreesChunk>>) (g => g.Chunks)).SelectMany<TreesManager.ITreesChunk, TreeId>((Func<TreesManager.ITreesChunk, IEnumerable<TreeId>>) (c => (IEnumerable<TreeId>) c.TreesSelectedToHarvest));
    }

    public IEnumerable<TreeId> EnumerateReservedTrees()
    {
      return this.m_treeGroups.Values.Where<TreesManager.TreesGroup>((Func<TreesManager.TreesGroup, bool>) (g => g.ReservedCount > 0)).SelectMany<TreesManager.TreesGroup, TreesManager.ITreesChunk>((Func<TreesManager.TreesGroup, IEnumerable<TreesManager.ITreesChunk>>) (g => g.Chunks)).SelectMany<TreesManager.ITreesChunk, TreeId>((Func<TreesManager.ITreesChunk, IEnumerable<TreeId>>) (c => (IEnumerable<TreeId>) c.ReservedTrees));
    }

    public bool TryGetTreeAndSelected(TreeId tree, out TreeData treeData, out bool selected)
    {
      if (!this.m_trees.TryGetValue(tree, out treeData))
      {
        selected = false;
        return false;
      }
      TreesManager.TreesGroup treesGroup;
      if (!this.m_treeGroups.TryGetValue(treeData.HarvestedProductId, out treesGroup))
      {
        selected = false;
        return false;
      }
      selected = treesGroup.IsTreeSelected(tree);
      return true;
    }

    public bool IsTreeSelected(TreeId tree)
    {
      TreeData treeData;
      TreesManager.TreesGroup treesGroup;
      return this.m_trees.TryGetValue(tree, out treeData) && this.m_treeGroups.TryGetValue(treeData.HarvestedProductId, out treesGroup) && treesGroup.IsTreeSelected(tree);
    }

    public void AddControlTower(ForestryTower tower, EntityAddReason addReason)
    {
      this.m_forestryTowers.Add(tower);
    }

    public void RemoveControlTower(ForestryTower tower, EntityRemoveReason removeReason)
    {
      if (this.m_forestryTowers.Remove(tower))
        return;
      Log.Error(string.Format("Failed to locate removed tower: {0}", (object) tower));
    }

    public bool IsTreeReserved(TreeId tree)
    {
      TreeData treeData;
      TreesManager.TreesGroup treesGroup;
      return this.m_trees.TryGetValue(tree, out treeData) && this.m_treeGroups.TryGetValue(treeData.HarvestedProductId, out treesGroup) && treesGroup.IsTreeReserved(tree);
    }

    private Lyst<TreeData> getSaveData()
    {
      this.m_saveDataTmp.Clear();
      foreach (TreeData treeData in this.m_trees.Values)
      {
        if (!treeData.CreatedByTerrainGenerator)
          this.m_saveDataTmp.Add(treeData);
      }
      return this.m_saveDataTmp;
    }

    private void terrainHeightChanged(Tile2iAndIndex tileAndIndex)
    {
      TreeId treeId = new TreeId(tileAndIndex.TileCoordSlim);
      if (this.m_trees.ContainsKey(treeId))
      {
        HeightTilesF plantedAtHeight = this.m_trees[treeId].PlantedAtHeight;
        HeightTilesF height = this.m_terrainManager.GetHeight(tileAndIndex.Index);
        if (height >= plantedAtHeight + TreesManager.TREE_COLLAPSE_UPPER_BOUND || height <= plantedAtHeight - TreesManager.TREE_COLLAPSE_LOWER_BOUND)
        {
          Action<TreeId> collapseTriggered = this.TreeCollapseTriggered;
          if (collapseTriggered != null)
            collapseTriggered(treeId);
          this.TryRemoveTree(treeId);
        }
      }
      if (!this.m_stumps.ContainsKey(treeId))
        return;
      HeightTilesF plantedAtHeight1 = this.m_stumps[treeId].PlantedAtHeight;
      HeightTilesF heightTilesF = this.m_terrainManager.GetHeight(tileAndIndex.Index) + this.m_stumps[treeId].GetDeltaHeight(this.m_calendar);
      if (!(heightTilesF >= plantedAtHeight1 + TreesManager.STUMP_COLLAPSE_UPPER_BOUND) && !(heightTilesF <= plantedAtHeight1 - TreesManager.STUMP_COLLAPSE_LOWER_BOUND))
        return;
      this.TryRemoveStump(treeId);
    }

    public bool TryAddTree(TreeData data)
    {
      Assert.That<bool>(data.CreatedByTerrainGenerator).IsFalse();
      if (!this.m_trees.TryAdd(data.Id, data))
      {
        Log.InfoDebug(string.Format("Failed to add tree '{0}'", (object) data.Id));
        return false;
      }
      if (!this.TryRemoveManualTree((Tile2i) data.Id.Position, true))
      {
        this.generateSignedDistanceField((Tile2i) data.Id.Position, data.Proto.SpacingToOtherTree);
        this.m_tileFlagReporter.SetFlag(this.m_terrainManager.ExtendTileIndex(data.Id.Position));
      }
      this.m_treeGroups.GetValueOrCreateDefault<ProductProto.ID, TreesManager.TreesGroup>(data.HarvestedProductId).AddTree(data.Id);
      this.m_treeAdded.Invoke(data);
      foreach (ForestryTower forestryTower in this.m_forestryTowers)
        forestryTower.TryAddTree(data);
      this.TryRemoveStump(data.Id);
      this.m_terrainPropManagerLazy.Value.TryRemovePropAtTile((Tile2i) data.Id.Position);
      return true;
    }

    private void generateSignedDistanceField(Tile2i origin, int spacing)
    {
      int num = TreeProto.MAX_TREE_SPACING + spacing;
      for (int y = -num; y <= num; ++y)
      {
        for (int x = -num; x <= num; ++x)
        {
          Tile2i tile2i = origin + new RelTile2i(x, y);
          Chunk2i chunkCoord2i = tile2i.ChunkCoord2i;
          TreesManager.TreeDistanceChunk treeDistanceChunk;
          if (!this.m_treeDistanceChunks.TryGetValue(chunkCoord2i, out treeDistanceChunk))
          {
            treeDistanceChunk = new TreesManager.TreeDistanceChunk(chunkCoord2i);
            this.m_treeDistanceChunks[chunkCoord2i] = treeDistanceChunk;
          }
          RelTile2i location = tile2i - treeDistanceChunk.Origin.Tile2i;
          int intRounded = ((x * x + y * y).FastSqrtSmallInt() - (Fix32) spacing).ToIntRounded();
          treeDistanceChunk.UpdateDistanceAt(location, intRounded);
        }
      }
    }

    private void resetSignedDistanceField(Tile2i origin, int spacing)
    {
      int num1 = TreeProto.MAX_TREE_SPACING + spacing;
      ref TerrainManager.TerrainData local = ref this.m_terrainManager.GetMutableTerrainDataRef();
      for (int y = -num1; y <= num1; ++y)
      {
        for (int x = -num1; x <= num1; ++x)
        {
          Tile2i tile = origin + new RelTile2i(x, y);
          TreesManager.TreeDistanceChunk treeDistanceChunk;
          if (this.m_treeDistanceChunks.TryGetValue(tile.ChunkCoord2i, out treeDistanceChunk))
          {
            RelTile2i location = tile - treeDistanceChunk.Origin.Tile2i;
            treeDistanceChunk.ClearDistanceAt(location);
            Tile2iIndex tileIndex = this.m_terrainManager.GetTileIndex(tile);
            if (this.m_terrainManager.IsValidIndex(tileIndex))
              local.ChangedTiles.SetBit(tileIndex.Value);
          }
        }
      }
      int num2 = num1 + 2 * TreeProto.MAX_TREE_SPACING;
      Set<Chunk2i> set = new Set<Chunk2i>();
      Assert.That<int>(num2).IsLessOrEqual(2048);
      for (int y = -num2; y <= num2; y += 2 * num2)
      {
        for (int x = -num2; x <= num2; x += 2 * num2)
        {
          Chunk2i chunkCoord2i = (origin + new RelTile2i(x, y)).ChunkCoord2i;
          if (this.m_treeDistanceChunks.TryGetValue(chunkCoord2i, out TreesManager.TreeDistanceChunk _))
            set.Add(chunkCoord2i);
        }
      }
      foreach (TreesManager.TreesGroup treesGroup in this.m_treeGroups.Values)
      {
        foreach (Chunk2i chunkCoord in set)
        {
          foreach (TreeId key in treesGroup.GetAllTreesOnChunk(chunkCoord))
          {
            if (key.Position.AsFull.IsNear(origin, num1 + TreeProto.MAX_TREE_SPACING + this.m_trees[key].Proto.SpacingToOtherTree))
              this.generateSignedDistanceField((Tile2i) key.Position, this.m_trees[key].Proto.SpacingToOtherTree);
          }
        }
      }
      foreach (TreeId key in this.m_manualTrees.Keys)
      {
        if (key.Position.AsFull.IsNear(origin, num1 + TreeProto.MAX_TREE_SPACING + this.m_manualTrees[key].Proto.SpacingToOtherTree))
          this.generateSignedDistanceField((Tile2i) key.Position, this.m_manualTrees[key].Proto.SpacingToOtherTree);
      }
    }

    public bool TryRemoveTree(TreeId id)
    {
      TreeData treeData;
      if (!this.m_trees.TryRemove(id, out treeData))
        return false;
      this.m_manualTrees.Remove(treeData.Id);
      this.m_reservedManualTrees.Remove(treeData.Id);
      if (treeData.CreatedByTerrainGenerator)
        this.m_removedTreesCreatedWithTerrainGenerator.AddAndAssertNew(id);
      TreesManager.TreesGroup treesGroup;
      if (!this.m_treeGroups.TryGetValue(treeData.HarvestedProductId, out treesGroup))
      {
        Log.Error(string.Format("Failed to locate removed tree group: {0}", (object) treeData.HarvestedProductId));
        return false;
      }
      bool wasSelectedToHarvest;
      bool wasReserved;
      treesGroup.RemoveTree(id, out wasSelectedToHarvest, out wasReserved);
      this.resetSignedDistanceField((Tile2i) treeData.Id.Position, treeData.Proto.SpacingToOtherTree);
      foreach (ForestryTower forestryTower in this.m_forestryTowers)
        forestryTower.TryRemoveTree(treeData);
      TreeStumpData treeStumpData = new TreeStumpData(treeData, this.m_calendar);
      this.addStump(id, treeStumpData, false);
      this.m_tileFlagReporter.ClearFlag(this.m_terrainManager.ExtendTileIndex(treeData.Id.Position));
      foreach (ForestryTower forestryTower in this.m_forestryTowers)
        forestryTower.TryAddStump(treeStumpData);
      if (wasSelectedToHarvest)
      {
        --this.SelectedToHarvestCount;
        Assert.That<int>(this.SelectedToHarvestCount).IsNotNegative();
        this.m_treeRemovedFromHarvest.Invoke(id);
      }
      if (wasReserved)
      {
        --this.ReservedCount;
        Assert.That<int>(this.ReservedCount).IsNotNegative();
      }
      this.m_treeRemoved.Invoke(treeData);
      return true;
    }

    private void addStump(TreeId id, TreeStumpData data, bool fireFlagEvent = true)
    {
      this.m_stumps.Add(id, data);
      Chunk2i chunkCoord2i = id.Position.ChunkCoord2i;
      TreesManager.StumpsChunk stumpsChunk;
      if (!this.m_stumpChunks.TryGetValue(chunkCoord2i, out stumpsChunk))
      {
        stumpsChunk = new TreesManager.StumpsChunk(chunkCoord2i);
        this.m_stumpChunks[chunkCoord2i] = stumpsChunk;
      }
      stumpsChunk.Stumps.AddAndAssertNew(id);
      this.m_tileStumpFlagReporter.SetFlag(this.m_terrainManager.ExtendTileIndex(data.Id.Position));
      this.m_stumpAdded.Invoke(data);
    }

    public void RemoveStumpAtTile(Tile2i tile) => this.TryRemoveStump(new TreeId(tile.AsSlim));

    public bool TryRemoveStump(TreeId id)
    {
      TreesManager.StumpsChunk stumpsChunk;
      TreeStumpData stumpData;
      if (!this.m_stumpChunks.TryGetValue(id.Position.ChunkCoord2i, out stumpsChunk) || !this.m_stumps.TryRemove(id, out stumpData))
        return false;
      stumpsChunk.Stumps.Remove(id);
      foreach (ForestryTower forestryTower in this.m_forestryTowers)
        forestryTower.TryRemoveStump(stumpData);
      this.m_tileStumpFlagReporter.ClearFlag(this.m_terrainManager.ExtendTileIndex(stumpData.Id.Position));
      this.m_stumpRemoved.Invoke(stumpData);
      return true;
    }

    public bool HasTree(TreeId id) => this.m_trees.ContainsKey(id);

    public void AddToHarvest(TreeId id)
    {
      TreeData treeData;
      TreesManager.TreesGroup treesGroup;
      if (this.m_trees.TryGetValue(id, out treeData) && this.m_treeGroups.TryGetValue(treeData.HarvestedProductId, out treesGroup) && treesGroup.AddToHarvest(id))
      {
        Assert.That<ProductProto>(treeData.Proto.ProductWhenHarvested.Product).IsNotNullOrPhantom<ProductProto>();
        ++this.SelectedToHarvestCount;
        this.m_treeAddedToHarvest.Invoke(id);
      }
      else
        Assert.Fail<TreeId>("Failed to select a tree for harvest at {0}.", id);
    }

    public void AddToHarvestInArea(RectangleTerrainArea2i area, ProductProto.ID? harvestedProductId)
    {
      if (harvestedProductId.HasValue)
      {
        TreesManager.TreesGroup group;
        if (!this.m_treeGroups.TryGetValue(harvestedProductId.Value, out group))
          return;
        processArea(group);
      }
      else
      {
        foreach (TreesManager.TreesGroup group in this.m_treeGroups.Values)
          processArea(group);
      }

      void processArea(TreesManager.TreesGroup group)
      {
        this.m_treesInAreaTmp.Clear();
        group.AddToHarvestInArea(area, this.m_treesInAreaTmp);
        foreach (TreeId treeId in this.m_treesInAreaTmp)
        {
          ++this.SelectedToHarvestCount;
          this.m_treeAddedToHarvest.Invoke(treeId);
        }
      }
    }

    public void RemoveFromHarvest(TreeId id)
    {
      TreeData treeData;
      TreesManager.TreesGroup treesGroup;
      if (this.m_trees.TryGetValue(id, out treeData) && this.m_treeGroups.TryGetValue(treeData.HarvestedProductId, out treesGroup) && treesGroup.RemoveFromHarvest(id))
      {
        Assert.That<ProductProto>(treeData.Proto.ProductWhenHarvested.Product).IsNotNullOrPhantom<ProductProto>();
        --this.SelectedToHarvestCount;
        Assert.That<int>(this.SelectedToHarvestCount).IsNotNegative();
        this.m_treeRemovedFromHarvest.Invoke(id);
      }
      else
        Assert.Fail<TreeId>("Failed to remove a tree from harvest at {0}.", id);
    }

    public void RemoveFromHarvestInArea(
      RectangleTerrainArea2i area,
      ProductProto.ID? harvestedProductId)
    {
      if (harvestedProductId.HasValue)
      {
        TreesManager.TreesGroup group;
        if (!this.m_treeGroups.TryGetValue(harvestedProductId.Value, out group))
          return;
        processArea(group);
      }
      else
      {
        foreach (TreesManager.TreesGroup group in this.m_treeGroups.Values)
          processArea(group);
      }

      void processArea(TreesManager.TreesGroup group)
      {
        this.m_treesInAreaTmp.Clear();
        group.RemoveFromHarvestInArea(area, this.m_treesInAreaTmp);
        foreach (TreeId treeId in this.m_treesInAreaTmp)
        {
          --this.SelectedToHarvestCount;
          Assert.That<int>(this.SelectedToHarvestCount).IsNotNegative();
          this.m_treeRemovedFromHarvest.Invoke(treeId);
        }
      }
    }

    public bool TryReserveTree(TreeId id)
    {
      TreeData treeData;
      TreesManager.TreesGroup treesGroup;
      if (!this.m_trees.TryGetValue(id, out treeData) || !this.m_treeGroups.TryGetValue(treeData.HarvestedProductId, out treesGroup) || !treesGroup.TryReserveTree(id))
        return false;
      Assert.That<ProductProto>(treeData.Proto.ProductWhenHarvested.Product).IsNotNullOrPhantom<ProductProto>();
      ++this.ReservedCount;
      return true;
    }

    public bool TryCancelTreeReservation(TreeId id)
    {
      TreeData treeData;
      TreesManager.TreesGroup treesGroup;
      if (!this.m_trees.TryGetValue(id, out treeData) || !this.m_treeGroups.TryGetValue(treeData.HarvestedProductId, out treesGroup) || !treesGroup.TryCancelTreeReservation(id))
        return false;
      Assert.That<ProductProto>(treeData.Proto.ProductWhenHarvested.Product).IsNotNullOrPhantom<ProductProto>();
      --this.ReservedCount;
      Assert.That<int>(this.ReservedCount).IsNotNegative();
      return true;
    }

    public TreeId? FindClosestNonTowerTreeForHarvestFor(
      Vehicle vehicle,
      ProductProto.ID productId,
      IReadOnlySet<TreeId> unreachableTrees = null,
      IReadOnlySet<Chunk2i> unreachableTreeChunks = null)
    {
      TreesManager.TreesGroup treesGroup;
      if (!this.m_treeGroups.TryGetValue(productId, out treesGroup) || treesGroup.ReservedCount == treesGroup.TotalCount)
        return new TreeId?();
      Tile2i groundPositionTile2i = vehicle.GroundPositionTile2i;
      Set<Chunk2i> set = (Set<Chunk2i>) null;
      do
      {
        TreesManager.ITreesChunk treesChunk = (TreesManager.ITreesChunk) null;
        long num1 = long.MaxValue;
        if (treesGroup.SelectedCount > treesGroup.ReservedCount)
        {
          foreach (TreesManager.ITreesChunk chunk in treesGroup.Chunks)
          {
            if (chunk.TreesSelectedToHarvest.Count > chunk.ReservedTrees.Count && (set == null || !set.Contains(chunk.Origin)) && (unreachableTreeChunks == null || !unreachableTreeChunks.Contains(chunk.Origin)))
            {
              long num2 = chunk.Origin.CenterTile2i.DistanceSqrTo(groundPositionTile2i);
              if (num2 < num1)
              {
                num1 = num2;
                treesChunk = chunk;
              }
            }
          }
        }
        if (treesChunk == null)
          return new TreeId?();
        TreeId? treeForHarvestFor = new TreeId?();
        long num3 = long.MaxValue;
        foreach (TreeId treeId in (IEnumerable<TreeId>) treesChunk.TreesSelectedToHarvest)
        {
          if (!treesChunk.ReservedTrees.Contains(treeId) && (unreachableTrees == null || !unreachableTrees.Contains(treeId)))
          {
            long num4 = groundPositionTile2i.DistanceSqrTo((Tile2i) treeId.Position);
            if (num4 < num3)
            {
              treeForHarvestFor = new TreeId?(treeId);
              num3 = num4;
            }
          }
        }
        if (treeForHarvestFor.HasValue)
          return treeForHarvestFor;
        if (set == null)
          set = new Set<Chunk2i>();
        if (vehicle is TreeHarvester treeHarvester)
          treeHarvester.MarkTreeChunkAsUnreachable(treesChunk.Origin);
        set.Add(treesChunk.Origin);
      }
      while (set.Count < TreesManager.MAX_CHUNKS_TO_SEARCH);
      return new TreeId?();
    }

    public TreeId? FindClosestTowerTreeForHarvestFor(
      Vehicle vehicle,
      ProductProto.ID productId,
      IReadOnlySet<TreeId> unreachableTrees,
      out Option<ForestryTower> tower)
    {
      Tile2i groundPositionTile2i = vehicle.GroundPositionTile2i;
      long num1 = long.MaxValue;
      tower = Option<ForestryTower>.None;
      foreach (ForestryTower forestryTower in this.m_forestryTowers)
      {
        if (forestryTower.TreeHarvestersTotal <= 0 && forestryTower.HasTreeReadyToHarvest(productId))
        {
          long num2 = groundPositionTile2i.DistanceSqrTo(forestryTower.Position2f.Tile2i);
          if (num2 < num1)
          {
            tower = (Option<ForestryTower>) forestryTower;
            num1 = num2;
          }
        }
      }
      if (!tower.HasValue)
        return new TreeId?();
      TreeId? treeForHarvestFor = tower.Value.FindClosestTreeForHarvestFor(vehicle, productId, unreachableTrees);
      if (treeForHarvestFor.HasValue)
        return treeForHarvestFor;
      Log.Error("Best tree is null?");
      return new TreeId?();
    }

    public Option<ForestryTower> FindClosestTowerForPlantingFor(Vehicle vehicle)
    {
      Tile2i groundPositionTile2i = vehicle.GroundPositionTile2i;
      long num1 = long.MaxValue;
      Option<ForestryTower> towerForPlantingFor = Option<ForestryTower>.None;
      foreach (ForestryTower forestryTower in this.m_forestryTowers)
      {
        if (forestryTower.TreePlantersTotal <= 0 && forestryTower.HasPossiblePlantingPos() && !forestryTower.TreeTypes.IsEmpty<KeyValuePair<TreePlantingGroupProto, int>>())
        {
          long num2 = groundPositionTile2i.DistanceSqrTo(forestryTower.Position2f.Tile2i);
          if (num2 < num1)
          {
            towerForPlantingFor = (Option<ForestryTower>) forestryTower;
            num1 = num2;
          }
        }
      }
      return towerForPlantingFor;
    }

    /// <summary>
    /// Removes a tree from a terrain and returns the products from the tree.
    /// </summary>
    public ProductQuantity HarvestTree(TreeId id)
    {
      TreeData treeData;
      if (!this.m_trees.TryGetValue(id, out treeData))
      {
        Assert.Fail(string.Format("Failed to find tree {0} when harvesting", (object) id));
        return ProductQuantity.None;
      }
      Quantity quantity = treeData.Proto.ProductWhenHarvested.Quantity.ScaledByCeiled(treeData.GetScaleIgnoringBase(this.m_calendar));
      this.TryRemoveTree(id);
      ProductQuantity productQuantity = treeData.Proto.ProductWhenHarvested.Product.WithQuantity(quantity);
      this.m_productsManager.ProductCreated(productQuantity, CreateReason.MinedFromTerrain);
      return productQuantity;
    }

    public bool IsBlockedOrOccupied(Tile2i position)
    {
      Tile2iIndex tileIndex = this.m_terrainManager.GetTileIndex(position);
      return this.m_terrainManager.IsBlockingBuildings(tileIndex) || this.m_occupancyManager.IsOccupied(tileIndex);
    }

    public bool HasEnoughSpacingToOtherTrees(Tile2i position, int spacing)
    {
      Chunk2i chunkCoord2i = position.ChunkCoord2i;
      TreesManager.TreeDistanceChunk treeDistanceChunk;
      return !this.m_treeDistanceChunks.TryGetValue(chunkCoord2i, out treeDistanceChunk) || treeDistanceChunk.GetDistanceAt(position - chunkCoord2i.Tile2i) >= spacing;
    }

    public bool IsGroundFertileAtPosition(Tile2i position)
    {
      return TreesManager.TREE_FERTILITY_REQUIREMENT - this.m_farmableManager.GetFarmableThickness(position, TreesManager.TREE_FERTILITY_REQUIREMENT, out bool _) < TreesManager.TREE_FERTILITY_REQUIREMENT;
    }

    /// <summary>
    /// Checks if it is allowed to plant a tree at this location.
    /// </summary>
    public bool IsValidTileForPlanting(Tile2i position, int spacing)
    {
      return !this.IsBlockedOrOccupied(position) && this.IsGroundFertileAtPosition(position) && this.HasEnoughSpacingToOtherTrees(position, spacing);
    }

    /// <summary>Plants a tree with given proto at given location.</summary>
    public bool TryPlantTree(
      TreeProto proto,
      Tile2f position,
      AngleSlim rotation,
      Percent? baseScale = null)
    {
      HeightTilesF height = this.m_terrainManager.GetHeight(position);
      Percent baseScale1 = baseScale ?? proto.GetRandomBaseScale(this.m_randomNumberGenerator);
      return this.TryAddTree(new TreeData(proto, position, height, baseScale1, this.m_calendar.RealTime.Ticks, rotation));
    }

    private void terrainDataGenerated(GeneratedTerrainData terrainData, bool gameIsBeingLoaded)
    {
      foreach (ChunkTerrainData chunkTerrainData in terrainData.Chunks.Values)
      {
        for (int index = 0; index < chunkTerrainData.Data.Length; ++index)
        {
          TreeData treeData = chunkTerrainData.Data[index].TreeData;
          if (treeData.IsValid)
          {
            if (this.m_trees.TryAdd(treeData.Id, treeData))
            {
              this.m_terrainPropManagerLazy.Value.TryRemovePropAtTile((Tile2i) treeData.Id.Position);
              this.m_treeGroups.GetValueOrCreateDefault<ProductProto.ID, TreesManager.TreesGroup>(treeData.HarvestedProductId).AddTree(treeData.Id);
              this.m_tileFlagReporter.SetFlagNoEvents(this.m_terrainManager.GetTileIndex(treeData.Id.Position));
            }
            else
              Log.Error(string.Format("Failed to add tree '{0}' after load.", (object) treeData.Id));
          }
        }
      }
    }

    public bool TryAddGeneratedTree(TreeDataBase treeData)
    {
      TreeId treeId = new TreeId(treeData.Position.Tile2i.AsSlim);
      HeightTilesF height = this.m_terrainManager.GetHeight(treeData.Position);
      TreeData treeData1 = new TreeData(treeData, height, TreesManager.GENERATED_TREE_PLANTED_AT_TICK, true);
      if (this.m_trees.TryAdd(treeId, treeData1))
      {
        this.m_terrainPropManagerLazy.Value.TryRemovePropAtTile((Tile2i) treeId.Position);
        this.m_treeGroups.GetValueOrCreateDefault<ProductProto.ID, TreesManager.TreesGroup>(treeData1.HarvestedProductId).AddTree(treeId);
        this.m_tileFlagReporter.SetFlagNoEvents(this.m_terrainManager.GetTileIndex(treeId.Position));
        this.m_treeAdded.Invoke(treeData1);
        return true;
      }
      Log.Error(string.Format("Failed to add tree '{0}' after load.", (object) treeId));
      return false;
    }

    public bool TryRemoveGeneratedTree(TreeId treeId)
    {
      TreeData treeData;
      if (!this.m_trees.TryRemove(treeId, out treeData))
        return false;
      this.m_treeGroups.GetValueOrCreateDefault<ProductProto.ID, TreesManager.TreesGroup>(treeData.HarvestedProductId).RemoveTree(treeId, out bool _, out bool _);
      this.m_tileFlagReporter.ClearFlagNoEvents(this.m_terrainManager.GetTileIndex(treeId.Position));
      this.m_treeRemoved.Invoke(treeData);
      return true;
    }

    private void terrainGeneratedButNotLoaded()
    {
      foreach (TreeId treeId in this.m_removedTreesCreatedWithTerrainGenerator)
      {
        TreeData treeData;
        if (!this.m_trees.TryRemove(treeId, out treeData))
        {
          Log.Warning(string.Format("Tree at {0} was not generated.", (object) treeId.Position));
        }
        else
        {
          Assert.That<bool>(treeData.CreatedByTerrainGenerator).IsTrue();
          TreesManager.TreesGroup treesGroup;
          if (!this.m_treeGroups.TryGetValue(treeData.HarvestedProductId, out treesGroup))
          {
            Log.Error(string.Format("Failed to locate removed tree group: {0}", (object) treeData.HarvestedProductId));
          }
          else
          {
            this.m_tileFlagReporter.ClearFlagNoEvents(this.m_terrainManager.GetTileIndex(treeId.Position));
            treesGroup.RemoveTree(treeId, out bool _, out bool _);
          }
        }
      }
      foreach (TreeData treeData in this.m_trees.Values)
        this.generateSignedDistanceField((Tile2i) treeData.Id.Position, treeData.Proto.SpacingToOtherTree);
      foreach (TreeData treeData in this.m_saveDataTmp)
      {
        Assert.That<ProductProto>(treeData.Proto.ProductWhenHarvested.Product).IsNotNullOrPhantom<ProductProto>();
        if (!this.m_trees.TryAdd(treeData.Id, treeData))
        {
          Log.Error(string.Format("Trying to add already present tree {0}.", (object) treeData.Id));
          return;
        }
        this.m_tileFlagReporter.SetFlagNoEvents(this.m_terrainManager.GetTileIndex(treeData.Id.Position));
        this.m_treeGroups.GetValueOrCreateDefault<ProductProto.ID, TreesManager.TreesGroup>(treeData.HarvestedProductId).AddTree(treeData.Id);
      }
      this.m_saveDataTmp.Clear();
      foreach (TreeId loadedSelectedTree in this.m_loadedSelectedTrees)
      {
        TreeData treeData;
        if (!this.m_trees.TryGetValue(loadedSelectedTree, out treeData))
          Log.Error("Tree was not loaded yet?");
        this.m_treeGroups.GetValueOrCreateDefault<ProductProto.ID, TreesManager.TreesGroup>(treeData.HarvestedProductId).AddToHarvest(loadedSelectedTree);
      }
      this.m_loadedSelectedTrees = (Lyst<TreeId>) null;
      foreach (TreeId loadedReservedTree in this.m_loadedReservedTrees)
      {
        TreeData treeData;
        if (!this.m_trees.TryGetValue(loadedReservedTree, out treeData))
          Log.Error("Tree was not loaded yet?");
        this.m_treeGroups.GetValueOrCreateDefault<ProductProto.ID, TreesManager.TreesGroup>(treeData.HarvestedProductId).TryReserveTree(loadedReservedTree);
      }
      this.m_loadedReservedTrees = (Lyst<TreeId>) null;
      foreach (TreeId key in this.m_stumps.Keys)
        this.m_tileStumpFlagReporter.SetFlagNoEvents(this.m_terrainManager.GetTileIndex(key.Position));
    }

    public IEnumerable<TreeId> EnumerateTreesInArea(
      RectangleTerrainArea2i area,
      ProductProto.ID? productIdToSelect = null,
      bool? selectedToHarvest = null)
    {
      // ISSUE: object of a compiler-generated type is created
      return (IEnumerable<TreeId>) new TreesManager.\u003CEnumerateTreesInArea\u003Ed__155(-2)
      {
        \u003C\u003E4__this = this,
        \u003C\u003E3__area = area,
        \u003C\u003E3__productIdToSelect = productIdToSelect,
        \u003C\u003E3__selectedToHarvest = selectedToHarvest
      };
    }

    public IEnumerable<TreeId> EnumerateStumpsInArea(RectangleTerrainArea2i area)
    {
      // ISSUE: object of a compiler-generated type is created
      return (IEnumerable<TreeId>) new TreesManager.\u003CEnumerateStumpsInArea\u003Ed__156(-2)
      {
        \u003C\u003E4__this = this,
        \u003C\u003E3__area = area
      };
    }

    public bool ContainsStumpInDesignation(IDesignation designation)
    {
      TerrainTile plusYneighbor = this.m_terrainManager[designation.OriginTileCoord];
      int num1 = 0;
      while (num1 < 4)
      {
        TerrainTile terrainTile = plusYneighbor;
        int num2 = 0;
        while (num2 < 4)
        {
          if (this.m_stumps.ContainsKey(new TreeId(terrainTile.TileCoordSlim)))
            return true;
          ++num2;
          terrainTile = terrainTile.PlusXNeighbor;
        }
        ++num1;
        plusYneighbor = plusYneighbor.PlusYNeighbor;
      }
      return false;
    }

    public void UpdateSelectedTreesInArea(
      RectangleTerrainArea2i area,
      ProductProto.ID? productIdToSelect,
      bool? selectedToHarvest,
      Set<TreeId> selection,
      Lyst<TreeId> addedTrees,
      Lyst<TreeId> removedTrees)
    {
      Assert.That<Lyst<TreeId>>(addedTrees).IsEmpty<TreeId>();
      Assert.That<Lyst<TreeId>>(removedTrees).IsEmpty<TreeId>();
      foreach (TreeId treeId in selection)
      {
        if (!area.ContainsVertex((Tile2i) treeId.Position))
          removedTrees.Add(treeId);
      }
      selection.RemoveRangeAndAssert(removedTrees);
      foreach (TreeId treeId in this.EnumerateTreesInArea(area, productIdToSelect, selectedToHarvest))
      {
        if (selection.Add(treeId))
          addedTrees.Add(treeId);
      }
    }

    public void Debug_ValidateCounts()
    {
      Assert.That<int>(this.m_trees.Count).IsEqualTo(this.m_treeGroups.Values.Sum<TreesManager.TreesGroup>((Func<TreesManager.TreesGroup, int>) (x => x.Chunks.Sum<TreesManager.ITreesChunk>((Func<TreesManager.ITreesChunk, int>) (data => data.TreesNotSelected.Count + data.TreesSelectedToHarvest.Count)))), "Total trees count does not match");
      Assert.That<int>(this.SelectedToHarvestCount).IsEqualTo(this.m_treeGroups.Values.Sum<TreesManager.TreesGroup>((Func<TreesManager.TreesGroup, int>) (x => x.Chunks.Sum<TreesManager.ITreesChunk>((Func<TreesManager.ITreesChunk, int>) (data => data.TreesSelectedToHarvest.Count)))), "Total trees selected for harvest count does not match");
      Assert.That<int>(this.ReservedCount).IsEqualTo(this.m_treeGroups.Values.Sum<TreesManager.TreesGroup>((Func<TreesManager.TreesGroup, int>) (x => x.Chunks.Sum<TreesManager.ITreesChunk>((Func<TreesManager.ITreesChunk, int>) (data => data.ReservedTrees.Count)))), "Total reserved trees count does not match");
      foreach (KeyValuePair<ProductProto.ID, TreesManager.TreesGroup> treeGroup in this.m_treeGroups)
      {
        TreesManager.TreesGroup treesGroup = treeGroup.Value;
        Assert.That<int>(treesGroup.ReservedCount).IsEqualTo<ProductProto.ID>(treesGroup.Chunks.Sum<TreesManager.ITreesChunk>((Func<TreesManager.ITreesChunk, int>) (data => data.ReservedTrees.Count)), "Reserved trees count does not match in group {0}.", treeGroup.Key);
        Assert.That<int>(treesGroup.SelectedCount).IsEqualTo<ProductProto.ID>(treesGroup.Chunks.Sum<TreesManager.ITreesChunk>((Func<TreesManager.ITreesChunk, int>) (data => data.TreesSelectedToHarvest.Count)), "Reserved trees count does not match in group {0}.", treeGroup.Key);
        Assert.That<int>(treesGroup.TotalCount).IsEqualTo<ProductProto.ID>(treesGroup.Chunks.Sum<TreesManager.ITreesChunk>((Func<TreesManager.ITreesChunk, int>) (data => data.TreesNotSelected.Count + data.TreesSelectedToHarvest.Count)), "Reserved trees count does not match in group {0}.", treeGroup.Key);
      }
    }

    void IAction<DesignateHarvestedTreesCmd>.Invoke(DesignateHarvestedTreesCmd cmd)
    {
      if (cmd.AddToHarvest)
        this.AddToHarvestInArea(cmd.Area, cmd.HarvestedProductId);
      else
        this.RemoveFromHarvestInArea(cmd.Area, cmd.HarvestedProductId);
      cmd.SetResultSuccess();
    }

    internal void ClearTreesOnChunk(Chunk2i chunkCoord)
    {
      foreach (TreesManager.TreesGroup treesGroup in this.m_treeGroups.Values)
      {
        Option<TreesManager.TreesChunkData> option = treesGroup.RemoveChunk(chunkCoord);
        if (!option.IsNone)
        {
          foreach (TreeId key in option.Value.TreesNotSelected)
          {
            TreeData treeData;
            if (this.m_trees.TryRemove(key, out treeData))
            {
              this.m_treeRemoved.Invoke(treeData);
              this.m_tileFlagReporter.ClearFlag(this.m_terrainManager.ExtendTileIndex(key.Position));
            }
          }
        }
      }
    }

    public AngleSlim GetRandomPlantingRotation() => this.m_randomNumberGenerator.NextAngleSlim();

    public bool TryAddManualTree(
      TreeProto proto,
      Tile2f position,
      AngleSlim rotation,
      Percent? baseScale = null)
    {
      TreeId key = new TreeId(position.Tile2i.AsSlim);
      if (!this.IsValidTileForPlanting((Tile2i) key.Position, proto.SpacingToOtherTree))
        return false;
      Percent baseScale1 = baseScale ?? proto.GetRandomBaseScale(this.m_randomNumberGenerator);
      TreeData treeData = new TreeData(proto, position, this.m_terrainManager.GetHeight(position), baseScale1, this.m_calendar.RealTime.Ticks, rotation);
      this.generateSignedDistanceField((Tile2i) key.Position, proto.SpacingToOtherTree);
      this.m_tileFlagReporter.SetFlag(this.m_terrainManager.ExtendTileIndex(key.Position));
      this.m_manualTrees.Add(key, treeData);
      this.m_treePreviewAdded.Invoke(treeData);
      this.m_manualTreePlaced.Invoke(key);
      return true;
    }

    public bool TryRemoveManualTree(Tile2i position, bool replacing)
    {
      TreeId key = new TreeId(position.AsSlim);
      TreeData treeData;
      this.m_manualTrees.TryGetValue(key, out treeData);
      if (!this.m_manualTrees.Remove(key))
        return false;
      this.m_reservedManualTrees.Remove(key);
      if (!replacing)
      {
        this.m_tileFlagReporter.ClearFlag(this.m_terrainManager.ExtendTileIndex(treeData.Id.Position));
        this.resetSignedDistanceField(position, treeData.Proto.SpacingToOtherTree);
      }
      this.m_treePreviewRemoved.Invoke(treeData);
      return true;
    }

    public bool TryGetManualTree(TreeId tree, out TreeData treeData)
    {
      return this.m_manualTrees.TryGetValue(tree, out treeData);
    }

    public bool TryGetAndReserveManualTree(
      Vehicle vehicle,
      IReadOnlySet<Tile2iSlim> unreachableTiles,
      out TreeData? treeData)
    {
      if (this.m_manualTrees.Count - this.m_reservedManualTrees.Count <= 0)
      {
        treeData = new TreeData?();
        return false;
      }
      Tile2iSlim asSlim = vehicle.GroundPositionTile2i.AsSlim;
      long num1 = long.MaxValue;
      KeyValuePair<TreeId, TreeData> keyValuePair = new KeyValuePair<TreeId, TreeData>();
      foreach (KeyValuePair<TreeId, TreeData> manualTree in this.m_manualTrees)
      {
        if (!this.m_reservedManualTrees.Contains(manualTree.Key) && !unreachableTiles.Contains(manualTree.Key.Position))
        {
          long num2 = (long) manualTree.Key.Position.DistanceSqrTo(asSlim);
          if (num2 < num1)
          {
            num1 = num2;
            keyValuePair = manualTree;
          }
        }
      }
      if (num1 == long.MaxValue)
      {
        if (unreachableTiles.IsEmpty<Tile2iSlim>())
          Log.Error(string.Format("Failed to get manual tree despite '{0}' available ", (object) (this.m_manualTrees.Count - this.m_reservedManualTrees.Count)));
        treeData = new TreeData?();
        return false;
      }
      this.m_reservedManualTrees.Add(keyValuePair.Key);
      treeData = new TreeData?(keyValuePair.Value);
      return true;
    }

    public bool HasReservedManualTree(Tile2i plantingPosition)
    {
      return this.m_reservedManualTrees.Contains(new TreeId(plantingPosition.AsSlim));
    }

    public bool TryCancelReserveManualTree(Tile2i plantingPosition)
    {
      return this.m_reservedManualTrees.Remove(new TreeId(plantingPosition.AsSlim));
    }

    public IEnumerable<TreeId> EnumerateManualTreesInArea(RectangleTerrainArea2i area)
    {
      // ISSUE: object of a compiler-generated type is created
      return (IEnumerable<TreeId>) new TreesManager.\u003CEnumerateManualTreesInArea\u003Ed__169(-2)
      {
        \u003C\u003E4__this = this,
        \u003C\u003E3__area = area
      };
    }

    static TreesManager()
    {
      MBiHIp97M4MqqbtZOh.rMWAw2OR8();
      TreesManager.s_serializeDataDelayedAction = (Action<object, BlobWriter>) ((obj, writer) => ((TreesManager) obj).SerializeData(writer));
      TreesManager.s_deserializeDataDelayedAction = (Action<object, BlobReader>) ((obj, reader) => ((TreesManager) obj).DeserializeData(reader));
      TreesManager.GENERATED_TREE_PLANTED_AT_TICK = -720000;
      TreesManager.STUMP_SINK_RATE_PER_MONTH = Fix32.FromFraction(1L, (long) (30 * Duration.OneYear).Months.IntegerPart);
      TreesManager.STUMP_COLLAPSE_UPPER_BOUND = 0.25.TilesThick();
      TreesManager.STUMP_COLLAPSE_LOWER_BOUND = 0.25.TilesThick();
      TreesManager.TREE_COLLAPSE_UPPER_BOUND = 1.0.TilesThick();
      TreesManager.TREE_COLLAPSE_LOWER_BOUND = 0.5.TilesThick();
      TreesManager.MAX_CHUNKS_TO_SEARCH = 5;
      TreesManager.TREE_FERTILITY_REQUIREMENT = 0.5.TilesThick();
      TreesManager.FOREST_FLOOR_REMOVE_SUBCHUNKS = 16;
      TreesManager.TILES_PER_UPDATE = 4096 / TreesManager.FOREST_FLOOR_REMOVE_SUBCHUNKS;
      TreesManager.MAX_FLOOR_THICKNESS_GAIN_PER_MONTH = 0.02.TilesThick();
      TreesManager.MAX_FLOOR_THICKNESS_LOSS_PER_MONTH = 0.01.TilesThick();
      TreesManager.MAX_FLOOR_THICKNESS_TOTAL = 1.0.TilesThick();
    }

    [GenerateSerializer(false, null, 0)]
    private class StumpsChunk
    {
      private static readonly Action<object, BlobWriter> s_serializeDataDelayedAction;
      private static readonly Action<object, BlobReader> s_deserializeDataDelayedAction;
      public readonly Set<TreeId> Stumps;

      public static void Serialize(TreesManager.StumpsChunk value, BlobWriter writer)
      {
        if (!writer.TryStartClassSerialization<TreesManager.StumpsChunk>(value))
          return;
        writer.EnqueueDataSerialization((object) value, TreesManager.StumpsChunk.s_serializeDataDelayedAction);
      }

      protected virtual void SerializeData(BlobWriter writer)
      {
        Chunk2i.Serialize(this.Origin, writer);
        Set<TreeId>.Serialize(this.Stumps, writer);
      }

      public static TreesManager.StumpsChunk Deserialize(BlobReader reader)
      {
        TreesManager.StumpsChunk stumpsChunk;
        if (reader.TryStartClassDeserialization<TreesManager.StumpsChunk>(out stumpsChunk))
          reader.EnqueueDataDeserialization((object) stumpsChunk, TreesManager.StumpsChunk.s_deserializeDataDelayedAction);
        return stumpsChunk;
      }

      protected virtual void DeserializeData(BlobReader reader)
      {
        this.Origin = Chunk2i.Deserialize(reader);
        reader.SetField<TreesManager.StumpsChunk>(this, "Stumps", (object) Set<TreeId>.Deserialize(reader));
      }

      public Chunk2i Origin { get; private set; }

      public StumpsChunk(Chunk2i origin)
      {
        MBiHIp97M4MqqbtZOh.rMWAw2OR8();
        // ISSUE: explicit constructor call
        base.\u002Ector();
        this.Origin = origin;
        this.Stumps = new Set<TreeId>();
      }

      static StumpsChunk()
      {
        MBiHIp97M4MqqbtZOh.rMWAw2OR8();
        TreesManager.StumpsChunk.s_serializeDataDelayedAction = (Action<object, BlobWriter>) ((obj, writer) => ((TreesManager.StumpsChunk) obj).SerializeData(writer));
        TreesManager.StumpsChunk.s_deserializeDataDelayedAction = (Action<object, BlobReader>) ((obj, reader) => ((TreesManager.StumpsChunk) obj).DeserializeData(reader));
      }
    }

    [GenerateSerializer(false, null, 0)]
    private class TreeDistanceChunk
    {
      private static readonly Action<object, BlobWriter> s_serializeDataDelayedAction;
      private static readonly Action<object, BlobReader> s_deserializeDataDelayedAction;
      private readonly byte[] m_distanceField;
      /// <summary>
      /// Whether we need to check this chunk for decaying forest floor.
      /// </summary>
      public bool IsForestFloorDirty;

      public static void Serialize(TreesManager.TreeDistanceChunk value, BlobWriter writer)
      {
        if (!writer.TryStartClassSerialization<TreesManager.TreeDistanceChunk>(value))
          return;
        writer.EnqueueDataSerialization((object) value, TreesManager.TreeDistanceChunk.s_serializeDataDelayedAction);
      }

      protected virtual void SerializeData(BlobWriter writer)
      {
        writer.WriteBool(this.IsForestFloorDirty);
        writer.WriteArray<byte>(this.m_distanceField);
        Chunk2i.Serialize(this.Origin, writer);
      }

      public static TreesManager.TreeDistanceChunk Deserialize(BlobReader reader)
      {
        TreesManager.TreeDistanceChunk treeDistanceChunk;
        if (reader.TryStartClassDeserialization<TreesManager.TreeDistanceChunk>(out treeDistanceChunk))
          reader.EnqueueDataDeserialization((object) treeDistanceChunk, TreesManager.TreeDistanceChunk.s_deserializeDataDelayedAction);
        return treeDistanceChunk;
      }

      protected virtual void DeserializeData(BlobReader reader)
      {
        this.IsForestFloorDirty = reader.ReadBool();
        reader.SetField<TreesManager.TreeDistanceChunk>(this, "m_distanceField", (object) reader.ReadArray<byte>());
        this.Origin = Chunk2i.Deserialize(reader);
      }

      public Chunk2i Origin { get; private set; }

      public TreeDistanceChunk(Chunk2i origin)
      {
        MBiHIp97M4MqqbtZOh.rMWAw2OR8();
        // ISSUE: explicit constructor call
        base.\u002Ector();
        this.Origin = origin;
        this.m_distanceField = new byte[4096];
      }

      /// <summary>
      /// Returns the value of the signed distance field from all trees. A value of zero
      /// should be understood as the outer bound of all current trees. Negative values are
      /// inside a tree's bounds, positive outside.
      /// </summary>
      /// <param name="location"></param>
      /// <returns></returns>
      public int GetDistanceAt(RelTile2i location)
      {
        return 128 - (int) this.m_distanceField[location.Y * 64 + location.X];
      }

      /// <summary>
      /// Returns the raw value of the distance field at an index.
      /// </summary>
      public byte GetRawDistanceAt(int rawIndex) => this.m_distanceField[rawIndex];

      /// <summary>
      /// Updates the signed distance as the closest distance of old and new values.
      /// A value of zero should be understood as the outer bound of all current trees.
      /// </summary>
      public void UpdateDistanceAt(RelTile2i location, int value)
      {
        if (value >= TreeProto.MAX_TREE_SPACING)
          return;
        int index = location.Y * 64 + location.X;
        this.m_distanceField[index] = (byte) (128 - value).Max((int) this.m_distanceField[index]);
      }

      /// <summary>Sets the distance to max distance at this point.</summary>
      public void ClearDistanceAt(RelTile2i location)
      {
        this.IsForestFloorDirty = true;
        this.m_distanceField[location.Y * 64 + location.X] = (byte) 0;
      }

      static TreeDistanceChunk()
      {
        MBiHIp97M4MqqbtZOh.rMWAw2OR8();
        TreesManager.TreeDistanceChunk.s_serializeDataDelayedAction = (Action<object, BlobWriter>) ((obj, writer) => ((TreesManager.TreeDistanceChunk) obj).SerializeData(writer));
        TreesManager.TreeDistanceChunk.s_deserializeDataDelayedAction = (Action<object, BlobReader>) ((obj, reader) => ((TreesManager.TreeDistanceChunk) obj).DeserializeData(reader));
      }
    }

    [GenerateSerializer(false, null, 0)]
    private class TreesChunkData : TreesManager.ITreesChunk
    {
      private static readonly Action<object, BlobWriter> s_serializeDataDelayedAction;
      private static readonly Action<object, BlobReader> s_deserializeDataDelayedAction;
      public readonly Set<TreeId> TreesNotSelected;
      public readonly Set<TreeId> TreesSelectedToHarvest;
      public readonly Set<TreeId> ReservedTrees;

      public static void Serialize(TreesManager.TreesChunkData value, BlobWriter writer)
      {
        if (!writer.TryStartClassSerialization<TreesManager.TreesChunkData>(value))
          return;
        writer.EnqueueDataSerialization((object) value, TreesManager.TreesChunkData.s_serializeDataDelayedAction);
      }

      protected virtual void SerializeData(BlobWriter writer)
      {
        Chunk2i.Serialize(this.Origin, writer);
        Set<TreeId>.Serialize(this.ReservedTrees, writer);
        Set<TreeId>.Serialize(this.TreesNotSelected, writer);
        Set<TreeId>.Serialize(this.TreesSelectedToHarvest, writer);
      }

      public static TreesManager.TreesChunkData Deserialize(BlobReader reader)
      {
        TreesManager.TreesChunkData treesChunkData;
        if (reader.TryStartClassDeserialization<TreesManager.TreesChunkData>(out treesChunkData))
          reader.EnqueueDataDeserialization((object) treesChunkData, TreesManager.TreesChunkData.s_deserializeDataDelayedAction);
        return treesChunkData;
      }

      protected virtual void DeserializeData(BlobReader reader)
      {
        this.Origin = Chunk2i.Deserialize(reader);
        reader.SetField<TreesManager.TreesChunkData>(this, "ReservedTrees", (object) Set<TreeId>.Deserialize(reader));
        reader.SetField<TreesManager.TreesChunkData>(this, "TreesNotSelected", (object) Set<TreeId>.Deserialize(reader));
        reader.SetField<TreesManager.TreesChunkData>(this, "TreesSelectedToHarvest", (object) Set<TreeId>.Deserialize(reader));
      }

      public Chunk2i Origin { get; private set; }

      IReadOnlySet<TreeId> TreesManager.ITreesChunk.TreesNotSelected
      {
        get => (IReadOnlySet<TreeId>) this.TreesNotSelected;
      }

      IReadOnlySet<TreeId> TreesManager.ITreesChunk.TreesSelectedToHarvest
      {
        get => (IReadOnlySet<TreeId>) this.TreesSelectedToHarvest;
      }

      IReadOnlySet<TreeId> TreesManager.ITreesChunk.ReservedTrees
      {
        get => (IReadOnlySet<TreeId>) this.ReservedTrees;
      }

      public TreesChunkData(Chunk2i origin)
      {
        MBiHIp97M4MqqbtZOh.rMWAw2OR8();
        // ISSUE: explicit constructor call
        base.\u002Ector();
        this.Origin = origin;
        this.TreesNotSelected = new Set<TreeId>();
        this.TreesSelectedToHarvest = new Set<TreeId>();
        this.ReservedTrees = new Set<TreeId>();
      }

      static TreesChunkData()
      {
        MBiHIp97M4MqqbtZOh.rMWAw2OR8();
        TreesManager.TreesChunkData.s_serializeDataDelayedAction = (Action<object, BlobWriter>) ((obj, writer) => ((TreesManager.TreesChunkData) obj).SerializeData(writer));
        TreesManager.TreesChunkData.s_deserializeDataDelayedAction = (Action<object, BlobReader>) ((obj, reader) => ((TreesManager.TreesChunkData) obj).DeserializeData(reader));
      }
    }

    [GenerateSerializer(false, null, 0)]
    private class TreesGroup
    {
      private static readonly Action<object, BlobWriter> s_serializeDataDelayedAction;
      private static readonly Action<object, BlobReader> s_deserializeDataDelayedAction;
      private readonly Dict<Chunk2i, TreesManager.TreesChunkData> m_chunks;

      public static void Serialize(TreesManager.TreesGroup value, BlobWriter writer)
      {
        if (!writer.TryStartClassSerialization<TreesManager.TreesGroup>(value))
          return;
        writer.EnqueueDataSerialization((object) value, TreesManager.TreesGroup.s_serializeDataDelayedAction);
      }

      protected virtual void SerializeData(BlobWriter writer)
      {
        Dict<Chunk2i, TreesManager.TreesChunkData>.Serialize(this.m_chunks, writer);
        writer.WriteInt(this.ReservedCount);
        writer.WriteInt(this.SelectedCount);
        writer.WriteInt(this.TotalCount);
      }

      public static TreesManager.TreesGroup Deserialize(BlobReader reader)
      {
        TreesManager.TreesGroup treesGroup;
        if (reader.TryStartClassDeserialization<TreesManager.TreesGroup>(out treesGroup))
          reader.EnqueueDataDeserialization((object) treesGroup, TreesManager.TreesGroup.s_deserializeDataDelayedAction);
        return treesGroup;
      }

      protected virtual void DeserializeData(BlobReader reader)
      {
        reader.SetField<TreesManager.TreesGroup>(this, "m_chunks", (object) Dict<Chunk2i, TreesManager.TreesChunkData>.Deserialize(reader));
        this.ReservedCount = reader.ReadInt();
        this.SelectedCount = reader.ReadInt();
        this.TotalCount = reader.ReadInt();
      }

      public int TotalCount { get; private set; }

      public int SelectedCount { get; private set; }

      public int ReservedCount { get; private set; }

      public IEnumerable<TreesManager.ITreesChunk> Chunks
      {
        get => (IEnumerable<TreesManager.ITreesChunk>) this.m_chunks.Values;
      }

      public void AddTree(TreeId id)
      {
        Chunk2i chunkCoord2i = id.Position.ChunkCoord2i;
        TreesManager.TreesChunkData treesChunkData;
        if (!this.m_chunks.TryGetValue(chunkCoord2i, out treesChunkData))
        {
          treesChunkData = new TreesManager.TreesChunkData(chunkCoord2i);
          this.m_chunks[chunkCoord2i] = treesChunkData;
        }
        treesChunkData.TreesNotSelected.AddAndAssertNew(id);
        Assert.That<Set<TreeId>>(treesChunkData.TreesSelectedToHarvest).NotContains<TreeId>(id);
        ++this.TotalCount;
      }

      public void RemoveTree(TreeId id, out bool wasSelectedToHarvest, out bool wasReserved)
      {
        wasSelectedToHarvest = false;
        wasReserved = false;
        TreesManager.TreesChunkData treesChunkData;
        if (!this.m_chunks.TryGetValue(id.Position.ChunkCoord2i, out treesChunkData))
        {
          Log.Error("Failed to remove tree, it was not found.");
        }
        else
        {
          if (treesChunkData.TreesNotSelected.Remove(id))
            Assert.That<Set<TreeId>>(treesChunkData.TreesSelectedToHarvest).NotContains<TreeId>(id);
          else if (treesChunkData.TreesSelectedToHarvest.Remove(id))
          {
            wasSelectedToHarvest = true;
            --this.SelectedCount;
            Assert.That<int>(this.SelectedCount).IsNotNegative();
          }
          else
          {
            Log.Error("Failed to remove tree, it was not found.");
            return;
          }
          --this.TotalCount;
          Assert.That<int>(this.TotalCount).IsNotNegative();
          if (!treesChunkData.ReservedTrees.Remove(id))
            return;
          --this.ReservedCount;
          Assert.That<int>(this.ReservedCount).IsNotNegative();
          wasReserved = true;
        }
      }

      public bool AddToHarvest(TreeId id)
      {
        TreesManager.TreesChunkData data;
        if (this.m_chunks.TryGetValue(id.Position.ChunkCoord2i, out data))
          return this.addToHarvestInternal(id, data);
        Log.Error("Failed to select tree, it was not found.");
        return false;
      }

      private bool addToHarvestInternal(TreeId id, TreesManager.TreesChunkData data)
      {
        if (!data.TreesNotSelected.Remove(id))
        {
          Log.Error("Failed to select tree, it was not found.");
          return false;
        }
        data.TreesSelectedToHarvest.Add(id);
        ++this.SelectedCount;
        Assert.That<int>(this.SelectedCount).IsLessOrEqual(this.TotalCount);
        return true;
      }

      public void AddToHarvestInArea(RectangleTerrainArea2i area, Lyst<TreeId> addedTrees)
      {
        Assert.That<Lyst<TreeId>>(addedTrees).IsEmpty<TreeId>();
        foreach (Chunk2i enumerateChunk in area.EnumerateChunks())
        {
          TreesManager.TreesChunkData data;
          if (this.m_chunks.TryGetValue(enumerateChunk, out data))
          {
            int count = addedTrees.Count;
            foreach (TreeId treeId in data.TreesNotSelected)
            {
              if (area.ContainsVertex((Tile2i) treeId.Position))
                addedTrees.Add(treeId);
            }
            for (int index = count; index < addedTrees.Count; ++index)
              this.addToHarvestInternal(addedTrees[index], data).AssertTrue();
          }
        }
      }

      public bool RemoveFromHarvest(TreeId id)
      {
        TreesManager.TreesChunkData data;
        if (this.m_chunks.TryGetValue(id.Position.ChunkCoord2i, out data))
          return this.removeFromHarvestInternal(id, data);
        Log.Error("Failed to unselect tree, it was not found.");
        return false;
      }

      private bool removeFromHarvestInternal(TreeId id, TreesManager.TreesChunkData data)
      {
        if (!data.TreesSelectedToHarvest.Remove(id))
        {
          Log.Error("Failed to unselect tree, it was not found.");
          return false;
        }
        data.TreesNotSelected.Add(id);
        --this.SelectedCount;
        Assert.That<int>(this.SelectedCount).IsNotNegative();
        return true;
      }

      public void RemoveFromHarvestInArea(RectangleTerrainArea2i area, Lyst<TreeId> removedTrees)
      {
        Assert.That<Lyst<TreeId>>(removedTrees).IsEmpty<TreeId>();
        foreach (Chunk2i enumerateChunk in area.EnumerateChunks())
        {
          TreesManager.TreesChunkData data;
          if (this.m_chunks.TryGetValue(enumerateChunk, out data))
          {
            int count = removedTrees.Count;
            foreach (TreeId treeId in data.TreesSelectedToHarvest)
            {
              if (area.ContainsVertex((Tile2i) treeId.Position))
                removedTrees.Add(treeId);
            }
            for (int index = count; index < removedTrees.Count; ++index)
              this.removeFromHarvestInternal(removedTrees[index], data).AssertTrue();
          }
        }
      }

      public bool TryReserveTree(TreeId id)
      {
        TreesManager.TreesChunkData treesChunkData;
        if (!this.m_chunks.TryGetValue(id.Position.ChunkCoord2i, out treesChunkData))
        {
          Log.Error("Failed to reserve tree, it was not found.");
          return false;
        }
        if (!treesChunkData.ReservedTrees.Add(id))
          return false;
        ++this.ReservedCount;
        Assert.That<int>(this.ReservedCount).IsLessOrEqual(this.TotalCount);
        return true;
      }

      public bool TryCancelTreeReservation(TreeId id)
      {
        TreesManager.TreesChunkData treesChunkData;
        if (!this.m_chunks.TryGetValue(id.Position.ChunkCoord2i, out treesChunkData))
        {
          Log.Error("Failed to un-reserve tree, it was not found.");
          return false;
        }
        if (!treesChunkData.ReservedTrees.Remove(id))
          return false;
        --this.ReservedCount;
        Assert.That<int>(this.ReservedCount).IsNotNegative();
        return true;
      }

      public IEnumerable<TreeId> GetAllTreesOnChunk(Chunk2i chunkCoord)
      {
        TreesManager.TreesChunkData treesChunkData;
        return !this.m_chunks.TryGetValue(chunkCoord, out treesChunkData) ? Enumerable.Empty<TreeId>() : treesChunkData.TreesNotSelected.Concat<TreeId>((IEnumerable<TreeId>) treesChunkData.TreesSelectedToHarvest);
      }

      public IEnumerable<TreeId> EnumerateTreesInArea(
        RectangleTerrainArea2i area,
        bool? selectedToHarvest = null)
      {
        // ISSUE: object of a compiler-generated type is created
        return (IEnumerable<TreeId>) new TreesManager.TreesGroup.\u003CEnumerateTreesInArea\u003Ed__32(-2)
        {
          \u003C\u003E4__this = this,
          \u003C\u003E3__area = area,
          \u003C\u003E3__selectedToHarvest = selectedToHarvest
        };
      }

      internal Option<TreesManager.TreesChunkData> RemoveChunk(Chunk2i coord)
      {
        TreesManager.TreesChunkData treesChunkData;
        return this.m_chunks.TryRemove(coord, out treesChunkData) ? (Option<TreesManager.TreesChunkData>) treesChunkData : Option<TreesManager.TreesChunkData>.None;
      }

      internal bool TryGetChunk(Chunk2i coord, out TreesManager.TreesChunkData data)
      {
        return this.m_chunks.TryGetValue(coord, out data);
      }

      public bool IsTreeSelected(TreeId tree)
      {
        TreesManager.TreesChunkData treesChunkData;
        return this.m_chunks.TryGetValue(tree.Position.ChunkCoord2i, out treesChunkData) && treesChunkData.TreesSelectedToHarvest.Contains(tree);
      }

      public bool IsTreeReserved(TreeId tree)
      {
        TreesManager.TreesChunkData treesChunkData;
        return this.m_chunks.TryGetValue(tree.Position.ChunkCoord2i, out treesChunkData) && treesChunkData.ReservedTrees.Contains(tree);
      }

      public TreesGroup()
      {
        MBiHIp97M4MqqbtZOh.rMWAw2OR8();
        this.m_chunks = new Dict<Chunk2i, TreesManager.TreesChunkData>();
        // ISSUE: explicit constructor call
        base.\u002Ector();
      }

      static TreesGroup()
      {
        MBiHIp97M4MqqbtZOh.rMWAw2OR8();
        TreesManager.TreesGroup.s_serializeDataDelayedAction = (Action<object, BlobWriter>) ((obj, writer) => ((TreesManager.TreesGroup) obj).SerializeData(writer));
        TreesManager.TreesGroup.s_deserializeDataDelayedAction = (Action<object, BlobReader>) ((obj, reader) => ((TreesManager.TreesGroup) obj).DeserializeData(reader));
      }
    }

    public interface ITreesChunk
    {
      Chunk2i Origin { get; }

      IReadOnlySet<TreeId> TreesNotSelected { get; }

      IReadOnlySet<TreeId> TreesSelectedToHarvest { get; }

      IReadOnlySet<TreeId> ReservedTrees { get; }
    }
  }
}
